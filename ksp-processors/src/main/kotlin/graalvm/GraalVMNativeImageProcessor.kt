package dev.kord.ksp.graalvm

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSFile
import dev.kord.ksp.AvailableForReflectionOnGraalVMNativeImage
import dev.kord.ksp.companionObject
import dev.kord.ksp.getSymbolsWithAnnotation
import dev.kord.ksp.graalvm.ReflectConfigEntry.Field
import dev.kord.ksp.graalvm.ReflectConfigEntry.Method
import dev.kord.ksp.jvmBinaryName
import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable

/** [SymbolProcessorProvider] for [GraalVMNativeImageProcessor]. */
class GraalVMNativeImageProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor =
        GraalVMNativeImageProcessor(environment.codeGenerator, environment.logger, environment.options["project"]!!)
}

/**
 * [SymbolProcessor] that reads [Serializable] and [AvailableForReflectionOnGraalVMNativeImage] annotations and
 * generates [`reflect-config.json`](https://www.graalvm.org/latest/reference-manual/native-image/metadata/#reflection)
 * files for building native executables with
 * [GraalVM Native Image](https://www.graalvm.org/latest/reference-manual/native-image/).
 */
private class GraalVMNativeImageProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
    private val project: String,
) : SymbolProcessor {

    private var flushedEntries = false
    private val entries = mutableListOf<ReflectConfigEntry>()
    private val sources = mutableListOf<KSFile>()

    override fun finish() {
        logger.info("GraalVMNativeImageProcessor received finish signal")
        flushEntries()
    }

    override fun onError() {
        val count = entries.size
        if (flushedEntries) {
            logger.info("GraalVMNativeImageProcessor received error signal after $count entries were flushed")
        } else {
            logger.warn("GraalVMNativeImageProcessor received error signal while having $count unflushed entries")
        }
    }

    override fun process(resolver: Resolver): List<KSAnnotated> {
        logger.info("GraalVMNativeImageProcessor got called, resolving annotations...")

        entries += resolver
            .getSymbolsWithAnnotation<Serializable>()
            .filterIsInstance<KSClassDeclaration>()
            .onEach { it.containingFile?.let(sources::add) }
            .flatMap(::entriesForSerializableClass)

        entries += resolver
            .getSymbolsWithAnnotation<AvailableForReflectionOnGraalVMNativeImage>()
            .onEach { if (it !is KSClassDeclaration) logger.warn("found annotation on wrong symbol", symbol = it) }
            .filterIsInstance<KSClassDeclaration>()
            .onEach { it.containingFile?.let(sources::add) }
            .map { ReflectConfigEntry(name = it.jvmBinaryName) }

        logger.info("GraalVMNativeImageProcessor finished processing annotations")

        return emptyList() // we never have to defer any symbols
    }

    private fun flushEntries() {
        check(!flushedEntries) { "already flushed entries" }
        flushedEntries = true
        if (entries.isNotEmpty()) {
            logger.info("flushing entries for project $project...")
            // sort by name to have a deterministic order
            val reflectConfigJson = entries.sortedBy { it.name }.encodeToReflectConfigJson()
            // this output is aggregating, see https://kotlinlang.org/docs/ksp-incremental.html#aggregating-vs-isolating
            val file = codeGenerator.createNewFileByPath(
                Dependencies(aggregating = true, *sources.toTypedArray()),
                path = "META-INF/native-image/dev.kord/kord-${project}/reflect-config",
                extensionName = "json",
            )
            file.writer().use { it.write(reflectConfigJson) }
            logger.info("finished flushing entries for project $project...")
        }
    }

    private fun entriesForSerializableClass(clazz: KSClassDeclaration): List<ReflectConfigEntry> {
        val binaryName = clazz.jvmBinaryName
        // companion object with default "Companion" name is generated by serialization plugin if not declared
        val companionObjectSimpleName = clazz.companionObject?.simpleName?.asString() ?: "Companion"

        val companionField = ReflectConfigEntry(
            name = binaryName,
            fields = listOf(Field(name = companionObjectSimpleName)),
        )
        val companionObject = ReflectConfigEntry(
            name = "$binaryName$$companionObjectSimpleName",
            methods = listOf(
                Method(
                    name = "serializer",
                    parameterTypes = clazz.typeParameters.map { KSerializer::class.qualifiedName!! },
                ),
            ),
        )

        return listOf(companionField, companionObject)
    }
}
